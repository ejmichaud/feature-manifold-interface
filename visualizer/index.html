<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAE Latent Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace;
            background: #fafafa;
            color: #1a1a1a;
            font-size: 13px;
            line-height: 1.5;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            padding: 12px 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .nav-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-btn {
            width: 32px;
            height: 32px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .nav-btn:hover {
            border-color: #ff4500;
            color: #ff4500;
        }

        .nav-btn:active {
            background: #fff5f0;
        }

        .latent-input {
            width: 80px;
            height: 32px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0 8px;
            font-family: inherit;
            font-size: 13px;
            text-align: center;
        }

        .latent-input:focus {
            outline: none;
            border-color: #ff4500;
        }

        .latent-range {
            color: #999;
            font-size: 11px;
        }

        /* Latent Info */
        .latent-info {
            display: flex;
            align-items: center;
            gap: 16px;
            flex: 1;
        }

        .latent-id {
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
        }

        .latent-label {
            background: #ff4500;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .latent-stats {
            color: #666;
            font-size: 11px;
        }

        /* Histogram */
        .histogram-container {
            width: 200px;
            height: 40px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
        }

        .histogram-container:hover::after {
            content: 'Click for log scale';
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 8px;
            color: #999;
        }

        .histogram-container.log-scale:hover::after {
            content: 'Click for linear';
        }

        .histogram-canvas {
            width: 100%;
            height: 100%;
        }

        /* Main content */
        .main {
            padding: 16px 20px;
        }

        /* Examples grid */
        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 8px;
        }

        .example {
            background: white;
            border: 1px solid #e8e8e8;
            border-radius: 6px;
            padding: 10px 12px;
            position: relative;
            transition: border-color 0.15s;
        }

        .example:hover {
            border-color: #ccc;
        }

        .example-rank {
            position: absolute;
            top: 6px;
            right: 8px;
            font-size: 10px;
            color: #bbb;
        }

        .example-activation {
            position: absolute;
            top: 6px;
            right: 30px;
            font-size: 10px;
            color: #ff4500;
            font-weight: 600;
        }

        .example-firings {
            position: absolute;
            top: 6px;
            right: 70px;
            font-size: 10px;
            color: #999;
        }

        .example-context {
            font-size: 13px;
            line-height: 1.7;
            word-wrap: break-word;
            padding-right: 80px;
        }

        /* Token highlighting */
        .token {
            display: inline;
            border-radius: 2px;
            transition: background 0.1s;
        }

        .token.highlighted {
            padding: 1px 0;
        }

        /* Activation intensity classes */
        .act-1 { background: rgba(255, 69, 0, 0.08); }
        .act-2 { background: rgba(255, 69, 0, 0.15); }
        .act-3 { background: rgba(255, 69, 0, 0.25); }
        .act-4 { background: rgba(255, 69, 0, 0.35); }
        .act-5 { background: rgba(255, 69, 0, 0.50); }
        .act-6 { background: rgba(255, 69, 0, 0.65); }
        .act-7 { background: rgba(255, 69, 0, 0.80); color: white; }
        .act-8 { background: rgba(255, 69, 0, 0.90); color: white; }
        .act-9 { background: rgba(255, 69, 0, 1.0); color: white; }

        /* Loading & Error states */
        .loading, .error {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .error {
            color: #cc0000;
            background: #fff0f0;
            border-radius: 8px;
            margin: 20px;
        }

        /* Keyboard hints */
        .keyboard-hints {
            font-size: 11px;
            color: #999;
        }

        .key {
            display: inline-block;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 1px 5px;
            font-size: 10px;
            margin: 0 2px;
        }

        /* Tooltip for token activation values */
        .token[title] {
            cursor: default;
        }

        /* Compact mode toggle */
        .view-toggle {
            display: flex;
            gap: 4px;
        }

        .view-btn {
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            color: #666;
        }

        .view-btn.active {
            background: #ff4500;
            border-color: #ff4500;
            color: white;
        }

        /* Ultra-compact list view */
        .examples-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .examples-list .example {
            padding: 6px 10px;
            border-radius: 4px;
        }

        .examples-list .example-context {
            font-size: 12px;
            line-height: 1.5;
        }

        .examples-list .example-rank {
            top: 4px;
        }

        .examples-list .example-activation {
            top: 4px;
        }

        .examples-list .example-firings {
            top: 4px;
        }

        /* Summary stats bar */
        .summary-bar {
            display: flex;
            gap: 20px;
            padding: 8px 0;
            margin-bottom: 12px;
            border-bottom: 1px solid #eee;
            font-size: 11px;
            color: #666;
        }

        .stat-item {
            display: flex;
            gap: 4px;
        }

        .stat-label {
            color: #999;
        }

        .stat-value {
            font-weight: 600;
            color: #333;
        }

        /* Loading indicator */
        .loading-indicator {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #ddd;
            border-top-color: #ff4500;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Section headers for percentile groups */
        .section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 24px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
        }

        .section-header:first-child {
            margin-top: 0;
        }

        .section-title {
            font-size: 13px;
            font-weight: 600;
            color: #333;
        }

        .section-range {
            font-size: 11px;
            color: #888;
            padding: 2px 8px;
            background: #f0f0f0;
            border-radius: 10px;
        }

        .section-count {
            font-size: 11px;
            color: #999;
        }

        /* Section colors */
        .section-header.top { border-bottom-color: #ff4500; }
        .section-header.high { border-bottom-color: #ff8c00; }
        .section-header.medium { border-bottom-color: #ffd700; }
        .section-header.low { border-bottom-color: #90ee90; }

        .section-header.top .section-title { color: #ff4500; }
        .section-header.high .section-title { color: #ff8c00; }
        .section-header.medium .section-title { color: #b8860b; }
        .section-header.low .section-title { color: #228b22; }

        .experiment-select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 12px;
            background: white;
            color: #333;
            max-width: 300px;
            cursor: pointer;
        }

        .experiment-select:hover {
            border-color: #ff4500;
        }

        .experiment-select:focus {
            outline: none;
            border-color: #ff4500;
        }

        /* Search */
        .search-container {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .search-input {
            width: 200px;
            height: 32px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0 8px;
            font-family: inherit;
            font-size: 13px;
        }

        .search-input:focus {
            outline: none;
            border-color: #ff4500;
        }

        .search-input::placeholder {
            color: #bbb;
        }

        .search-status {
            font-size: 10px;
            color: #999;
            white-space: nowrap;
        }

        /* Search results panel */
        .search-results-panel {
            position: sticky;
            top: 57px;
            background: white;
            border-bottom: 2px solid #ff4500;
            max-height: 60vh;
            overflow-y: auto;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .search-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 20px;
            background: #f8f8f8;
            border-bottom: 1px solid #eee;
            font-size: 11px;
            color: #666;
            position: sticky;
            top: 0;
        }

        .search-close-btn {
            background: none;
            border: none;
            font-size: 14px;
            cursor: pointer;
            color: #999;
            padding: 2px 6px;
        }

        .search-close-btn:hover {
            color: #333;
        }

        .search-results-list {
            padding: 2px 0;
        }

        .search-result {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f5f5f5;
            transition: background 0.1s;
        }

        .search-result:hover {
            background: #fff5f0;
        }

        .search-result-id {
            font-weight: 600;
            color: #333;
            min-width: 55px;
            font-size: 12px;
        }

        .search-result-label {
            background: #ff4500;
            color: white;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 11px;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .search-result-token {
            background: #e8e8e8;
            color: #333;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 11px;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .search-result-badge {
            font-size: 9px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-result-badge.label-match {
            color: #ff4500;
        }

        .search-result-stats {
            font-size: 11px;
            color: #999;
            margin-left: auto;
            white-space: nowrap;
        }

        .search-no-results {
            padding: 20px;
            text-align: center;
            color: #999;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="header">
        <select class="experiment-select" id="experiment-select" onchange="switchExperiment(this.value)">
            <option value="">Loading experiments...</option>
        </select>

        <div class="search-container">
            <input type="text" class="search-input" id="search-input" placeholder="Search latents..." />
            <span class="search-status" id="search-status"></span>
        </div>

        <div class="nav-controls">
            <button class="nav-btn" onclick="prevLatent()" title="Previous (←)">‹</button>
            <input type="number" class="latent-input" id="latent-input" value="0" min="0">
            <button class="nav-btn" onclick="nextLatent()" title="Next (→)">›</button>
            <span class="latent-range" id="latent-range"></span>
            <span class="loading-indicator" id="loading-indicator" style="display: none;"></span>
        </div>

        <div class="latent-info" id="latent-info">
            <span class="latent-id" id="latent-id">Latent 0</span>
            <span class="latent-label" id="latent-label"></span>
            <span class="latent-stats" id="latent-stats"></span>
        </div>

        <div class="histogram-container" id="histogram-container" title="Click to toggle log scale">
            <canvas class="histogram-canvas" id="histogram"></canvas>
        </div>

        <div class="view-toggle">
            <button class="view-btn" id="grid-btn" onclick="setView('grid')">Grid</button>
            <button class="view-btn active" id="list-btn" onclick="setView('list')">List</button>
        </div>

        <div class="keyboard-hints">
            <span class="key">←</span><span class="key">→</span> navigate
            <span class="key">g</span> go to
            <span class="key">/</span> search
        </div>
    </div>

    <div class="search-results-panel" id="search-results" style="display: none;">
        <div class="search-results-header">
            <span id="search-results-count"></span>
            <button class="search-close-btn" onclick="closeSearch()">&times;</button>
        </div>
        <div class="search-results-list" id="search-results-list"></div>
    </div>

    <div class="main">
        <div class="summary-bar" id="summary-bar"></div>
        <div id="content" class="examples-list"></div>
    </div>

    <script>
        // Configuration
        // Data root can be set via ?dataRoot= URL param (default: ../data)
        const _urlParams = new URLSearchParams(window.location.search);
        const DATA_ROOT = _urlParams.get('dataRoot') || '../data';
        const EXPERIMENTS_ROOT = `${DATA_ROOT}/experiments`;
        const MANIFEST_URL = `${DATA_ROOT}/experiments.json`;
        const EMBED_MODE = _urlParams.get('embed') === 'true';
        let DATA_DIR = null;  // Set when experiment is selected

        // State
        let experiments = [];
        let currentExperiment = null;
        let indexData = null;
        let currentLatent = 0;
        let maxLatent = 0;
        let currentView = 'list';
        let latentCache = new Map();  // Cache for loaded latent data
        const CACHE_SIZE = 50;  // Max latents to keep in cache
        let useLogScale = false;

        // Search state
        let searchIndex = null;        // Loaded from search_index.json
        let searchIndexLoading = false;
        let searchDebounceTimer = null;

        // Percentile section config
        const SECTIONS = [
            { key: 'top', title: 'Top Activations', range: '90-100%' },
            { key: 'high', title: 'High Activations', range: '70-90%' },
            { key: 'medium', title: 'Medium Activations', range: '40-70%' },
            { key: 'low', title: 'Low Activations', range: '10-40%' },
        ];

        async function loadExperiments() {
            const select = document.getElementById('experiment-select');

            try {
                const response = await fetch(MANIFEST_URL);
                if (!response.ok) throw new Error('No experiments manifest found');

                const manifest = await response.json();
                experiments = manifest.experiments.filter(e => e.has_visualizer);

                if (experiments.length === 0) {
                    select.innerHTML = '<option value="">No experiments with visualizer data</option>';
                    return;
                }

                // Populate dropdown
                select.innerHTML = experiments.map(exp => {
                    const label = `Layer ${exp.layer} / ${exp.sae_width} / ${exp.sae_l0}`;
                    const tokens = exp.num_tokens ? ` (${(exp.num_tokens/1e6).toFixed(0)}M tokens)` : '';
                    return `<option value="${exp.id}">${label}${tokens}</option>`;
                }).join('');

                // Check URL for experiment parameter
                const urlParams = new URLSearchParams(window.location.search);
                const expParam = urlParams.get('exp');
                const preferredDefault = 'gemma-3-27b-pt_layer16_65k_medium';
                const defaultExp = expParam && experiments.find(e => e.id === expParam)
                    ? expParam
                    : experiments.find(e => e.id === preferredDefault)?.id || experiments[0].id;

                select.value = defaultExp;
                await switchExperiment(defaultExp);

            } catch (error) {
                console.error('Failed to load experiments:', error);
                select.innerHTML = '<option value="">Error loading experiments</option>';

                // Fallback: try loading from legacy path
                DATA_DIR = '../data/latent_examples';
                await loadIndex();
            }
        }

        async function switchExperiment(experimentId) {
            if (!experimentId) return;

            currentExperiment = experiments.find(e => e.id === experimentId);
            DATA_DIR = `${EXPERIMENTS_ROOT}/${experimentId}/visualizer`;

            // Update URL without reload
            const url = new URL(window.location);
            url.searchParams.set('exp', experimentId);
            window.history.replaceState({}, '', url);

            // Clear current state
            indexData = null;
            currentLatent = 0;
            latentCache.clear();
            searchIndex = null;
            searchIndexLoading = false;
            closeSearch();
            document.getElementById('search-input').value = '';

            // Reset UI
            document.getElementById('content').innerHTML = '<div class="loading">Loading experiment...</div>';

            await loadIndex();
        }

        async function loadIndex() {
            try {
                const response = await fetch(`${DATA_DIR}/index.json`);
                if (!response.ok) throw new Error('Failed to load index');
                indexData = await response.json();

                maxLatent = indexData.n_latents - 1;
                document.getElementById('latent-range').textContent = `/ ${maxLatent.toLocaleString()}`;
                document.getElementById('latent-input').max = maxLatent;

                // Load search index in background
                loadSearchIndex();

                // Load initial latent (from URL param or default to 0)
                const latentParam = _urlParams.get('latent');
                loadLatent(latentParam !== null ? (parseInt(latentParam) || 0) : 0);
            } catch (error) {
                document.getElementById('content').innerHTML =
                    `<div class="error">
                        <strong>Error loading index:</strong> ${error.message}<br><br>
                        Run the pipeline: <code>python scripts/run_pipeline.py --config experiments/...</code>
                    </div>`;
            }
        }

        async function loadLatentData(latentId) {
            // Check cache first
            if (latentCache.has(latentId)) {
                return latentCache.get(latentId);
            }

            // Fetch from server
            const paddedId = String(latentId).padStart(5, '0');
            const response = await fetch(`${DATA_DIR}/latents/${paddedId}.json`);
            if (!response.ok) {
                throw new Error(`Failed to load latent ${latentId}`);
            }

            const data = await response.json();

            // Add to cache
            if (latentCache.size >= CACHE_SIZE) {
                // Remove oldest entry
                const firstKey = latentCache.keys().next().value;
                latentCache.delete(firstKey);
            }
            latentCache.set(latentId, data);

            return data;
        }

        async function loadLatent(id) {
            if (!indexData) return;

            currentLatent = Math.max(0, Math.min(id, maxLatent));
            document.getElementById('latent-input').value = currentLatent;

            // Show loading indicator
            document.getElementById('loading-indicator').style.display = 'inline-block';

            // Update header with index data (available immediately)
            const indexInfo = indexData.latents[currentLatent.toString()];
            document.getElementById('latent-id').textContent = `Latent ${currentLatent}`;

            const labelEl = document.getElementById('latent-label');
            if (indexInfo && indexInfo.label) {
                labelEl.textContent = `"${indexInfo.label}"`;
                labelEl.style.display = 'inline-block';
            } else {
                labelEl.style.display = 'none';
            }

            document.getElementById('latent-stats').textContent =
                indexInfo && indexInfo.total_firings ? `${indexInfo.total_firings.toLocaleString()} firings` : '';

            try {
                const latentData = await loadLatentData(currentLatent);
                renderLatent(latentData);
            } catch (error) {
                document.getElementById('content').innerHTML =
                    `<div class="error">Error loading latent ${currentLatent}: ${error.message}</div>`;
            } finally {
                document.getElementById('loading-indicator').style.display = 'none';
            }
        }

        function renderLatent(latentData) {
            // Handle both old format (top_examples) and new format (examples.top, etc.)
            const examples = latentData.examples || { top: latentData.top_examples || [] };
            const stats = latentData.activation_stats || {};
            const histogram = latentData.histogram;

            // Compute total examples count
            let totalExamples = 0;
            for (const key of Object.keys(examples)) {
                totalExamples += (examples[key] || []).length;
            }

            // Summary bar with stats
            const summaryParts = [
                `<div class="stat-item"><span class="stat-label">examples:</span><span class="stat-value">${totalExamples}</span></div>`,
            ];

            if (stats.max !== undefined) {
                summaryParts.push(`<div class="stat-item"><span class="stat-label">max:</span><span class="stat-value">${stats.max.toFixed(2)}</span></div>`);
            }
            if (stats.p90 !== undefined) {
                summaryParts.push(`<div class="stat-item"><span class="stat-label">p90:</span><span class="stat-value">${stats.p90.toFixed(2)}</span></div>`);
            }
            if (stats.p50 !== undefined) {
                summaryParts.push(`<div class="stat-item"><span class="stat-label">p50:</span><span class="stat-value">${stats.p50.toFixed(2)}</span></div>`);
            }
            if (stats.p10 !== undefined) {
                summaryParts.push(`<div class="stat-item"><span class="stat-label">p10:</span><span class="stat-value">${stats.p10.toFixed(2)}</span></div>`);
            }
            if (stats.min !== undefined) {
                summaryParts.push(`<div class="stat-item"><span class="stat-label">min:</span><span class="stat-value">${stats.min.toFixed(2)}</span></div>`);
            }

            document.getElementById('summary-bar').innerHTML = summaryParts.join('');

            // Draw histogram (from stored data if available, otherwise from examples)
            if (histogram && histogram.bins && histogram.bins.length > 0) {
                drawHistogramFromData(histogram);
            } else {
                // Fallback: compute from visible examples
                const allActivations = [];
                for (const key of Object.keys(examples)) {
                    for (const ex of (examples[key] || [])) {
                        allActivations.push(ex.max_activation || ex.activation || 0);
                    }
                }
                drawHistogramFromActivations(allActivations);
            }

            // Render examples by section
            const container = document.getElementById('content');
            const viewClass = currentView === 'grid' ? 'examples-grid' : 'examples-list';

            let html = '';
            let globalRank = 0;

            for (const section of SECTIONS) {
                const sectionExamples = examples[section.key] || [];
                if (sectionExamples.length === 0) continue;

                html += `
                    <div class="section-header ${section.key}">
                        <span class="section-title">${section.title}</span>
                        <span class="section-range">${section.range}</span>
                        <span class="section-count">${sectionExamples.length} examples</span>
                    </div>
                    <div class="${viewClass}">
                `;

                for (const example of sectionExamples) {
                    globalRank++;
                    const activation = example.max_activation || example.activation || 0;
                    const nFirings = example.n_firings || 1;
                    const tokens = renderTokens(example, stats.max || activation);

                    const firingsLabel = nFirings > 1 ? `${nFirings}x` : '';

                    html += `
                        <div class="example">
                            <span class="example-activation">${activation.toFixed(1)}</span>
                            ${firingsLabel ? `<span class="example-firings">${firingsLabel}</span>` : ''}
                            <span class="example-rank">#${globalRank}</span>
                            <div class="example-context">${tokens}</div>
                        </div>
                    `;
                }

                html += '</div>';
            }

            if (html === '') {
                html = '<div class="loading">No examples found for this latent</div>';
            }

            container.innerHTML = html;
        }

        function renderTokens(example, globalMax) {
            const tokens = example.tokens || [];
            const activations = example.token_activations || [];

            // Find max activation in this example for relative scaling
            const localMax = Math.max(...activations.filter(a => a > 0), 0.001);

            return tokens.map((token, idx) => {
                const act = activations[idx] || 0;
                const escaped = escapeHtml(token);

                if (act > 0) {
                    // Scale by local max for visibility, use 9 intensity levels
                    const intensity = Math.ceil((act / localMax) * 9);
                    const level = Math.min(9, Math.max(1, intensity));
                    return `<span class="token highlighted act-${level}" title="activation: ${act.toFixed(3)}">${escaped}</span>`;
                }

                return `<span class="token">${escaped}</span>`;
            }).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function drawHistogramFromData(histogram) {
            const canvas = document.getElementById('histogram');
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;

            // Clear
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, width, height);

            const bins = histogram.bins || [];
            const counts = histogram.counts || [];

            if (counts.length === 0) return;

            let maxCount = Math.max(...counts);
            if (useLogScale) {
                maxCount = Math.log10(maxCount + 1);
            }

            const barWidth = width / counts.length;

            // Draw bars
            counts.forEach((count, i) => {
                let barHeight;
                if (useLogScale) {
                    barHeight = count > 0 ? (Math.log10(count + 1) / maxCount) * (height - 4) : 0;
                } else {
                    barHeight = (count / maxCount) * (height - 4);
                }
                const x = i * barWidth;
                const y = height - barHeight - 2;

                // Gradient from light to dark orange based on position (activation value)
                const intensity = i / counts.length;
                ctx.fillStyle = `rgba(255, 69, 0, ${0.3 + intensity * 0.7})`;
                ctx.fillRect(x + 0.5, y, barWidth - 1, barHeight);
            });

            // Draw log scale indicator if active
            if (useLogScale) {
                ctx.fillStyle = '#666';
                ctx.font = '8px monospace';
                ctx.fillText('log', 2, 10);
            }
        }

        function drawHistogramFromActivations(activations) {
            const canvas = document.getElementById('histogram');
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;

            // Clear
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, width, height);

            if (!activations.length) return;

            // Compute histogram bins
            const numBins = 20;
            const min = Math.min(...activations);
            const max = Math.max(...activations);
            const range = max - min || 1;
            const binSize = range / numBins;

            const bins = new Array(numBins).fill(0);
            activations.forEach(act => {
                const binIdx = Math.min(numBins - 1, Math.floor((act - min) / binSize));
                bins[binIdx]++;
            });

            let maxBin = Math.max(...bins);
            if (useLogScale) {
                maxBin = Math.log10(maxBin + 1);
            }

            const barWidth = width / numBins;

            // Draw bars
            bins.forEach((count, i) => {
                let barHeight;
                if (useLogScale) {
                    barHeight = count > 0 ? (Math.log10(count + 1) / maxBin) * (height - 4) : 0;
                } else {
                    barHeight = (count / maxBin) * (height - 4);
                }
                const x = i * barWidth;
                const y = height - barHeight - 2;

                const intensity = i / numBins;
                ctx.fillStyle = `rgba(255, 69, 0, ${0.3 + intensity * 0.7})`;
                ctx.fillRect(x + 1, y, barWidth - 2, barHeight);
            });

            if (useLogScale) {
                ctx.fillStyle = '#666';
                ctx.font = '8px monospace';
                ctx.fillText('log', 2, 10);
            }
        }

        function toggleLogScale() {
            useLogScale = !useLogScale;
            document.getElementById('histogram-container').classList.toggle('log-scale', useLogScale);
            // Re-render current latent to update histogram
            if (latentCache.has(currentLatent)) {
                renderLatent(latentCache.get(currentLatent));
            }
        }

        function setView(view) {
            currentView = view;
            document.getElementById('grid-btn').classList.toggle('active', view === 'grid');
            document.getElementById('list-btn').classList.toggle('active', view === 'list');

            // Re-render to apply view change
            if (latentCache.has(currentLatent)) {
                renderLatent(latentCache.get(currentLatent));
            }
        }

        function prevLatent() {
            loadLatent(currentLatent - 1);
        }

        function nextLatent() {
            loadLatent(currentLatent + 1);
        }

        function goToLatent() {
            const input = document.getElementById('latent-input');
            loadLatent(parseInt(input.value) || 0);
        }

        // ─── Search ───────────────────────────────────────────

        async function loadSearchIndex() {
            if (searchIndex || searchIndexLoading || !DATA_DIR) return;

            searchIndexLoading = true;
            const statusEl = document.getElementById('search-status');
            statusEl.textContent = 'loading token index...';

            try {
                const response = await fetch(`${DATA_DIR}/search_index.json`);
                if (response.ok) {
                    searchIndex = await response.json();
                    statusEl.textContent = '';
                    // Re-run current search if input has text
                    const q = document.getElementById('search-input').value;
                    if (q) doSearch(q);
                } else {
                    statusEl.textContent = 'labels only';
                }
            } catch (e) {
                console.log('Search index not available, using label search only');
                statusEl.textContent = 'labels only';
            }
            searchIndexLoading = false;
        }

        function searchLatents(query) {
            if (!query || !indexData) return [];

            const q = query.toLowerCase().trim();
            if (!q) return [];

            const results = [];
            const seen = new Set();

            // 1. Label search (from indexData - always available)
            for (const [id, info] of Object.entries(indexData.latents)) {
                if (info.label && info.label.toLowerCase().includes(q)) {
                    const lid = parseInt(id);
                    results.push({
                        latent_id: lid,
                        label: info.label,
                        total_firings: info.total_firings || 0,
                        match_type: 'label',
                        matched_token: info.label,
                    });
                    seen.add(lid);
                }
            }

            // 2. Token search (from search index - if loaded)
            if (searchIndex && searchIndex.tokens) {
                // Track how many matching tokens each latent has for ranking
                const latentMatchCount = new Map();
                const latentFirstMatch = new Map();

                for (const [token, latent_ids] of Object.entries(searchIndex.tokens)) {
                    if (token.toLowerCase().includes(q)) {
                        for (const lid of latent_ids) {
                            if (!seen.has(lid)) {
                                latentMatchCount.set(lid, (latentMatchCount.get(lid) || 0) + 1);
                                if (!latentFirstMatch.has(lid)) {
                                    latentFirstMatch.set(lid, token);
                                }
                            }
                        }
                    }
                }

                // Add token-matched latents
                for (const [lid, count] of latentMatchCount) {
                    const info = indexData.latents[lid.toString()] || {};
                    results.push({
                        latent_id: lid,
                        label: info.label || '',
                        total_firings: info.total_firings || 0,
                        match_type: 'token',
                        matched_token: latentFirstMatch.get(lid),
                        match_count: count,
                    });
                    seen.add(lid);
                }
            }

            // Sort: label matches first, then by total_firings
            results.sort((a, b) => {
                if (a.match_type !== b.match_type) {
                    return a.match_type === 'label' ? -1 : 1;
                }
                return b.total_firings - a.total_firings;
            });

            return results;
        }

        function renderSearchResults(results, query) {
            const panel = document.getElementById('search-results');
            const list = document.getElementById('search-results-list');
            const countEl = document.getElementById('search-results-count');

            if (results.length === 0) {
                if (query && query.trim()) {
                    panel.style.display = 'block';
                    const indexNote = searchIndex ? '' : ' (label search only)';
                    countEl.textContent = `No matches${indexNote}`;
                    list.innerHTML = '<div class="search-no-results">No latents found</div>';
                } else {
                    panel.style.display = 'none';
                }
                return;
            }

            const maxResults = 200;
            const shown = results.slice(0, maxResults);
            const nLabels = results.filter(r => r.match_type === 'label').length;
            const nTokens = results.length - nLabels;

            let countParts = [];
            if (nLabels > 0) countParts.push(`${nLabels} label`);
            if (nTokens > 0) countParts.push(`${nTokens} token`);
            const total = results.length > maxResults
                ? `${maxResults} of ${results.length.toLocaleString()}`
                : `${results.length}`;
            countEl.textContent = `${total} match${results.length !== 1 ? 'es' : ''} (${countParts.join(', ')})`;

            list.innerHTML = shown.map(r => {
                const labelHtml = r.label
                    ? `<span class="search-result-label">&quot;${escapeHtml(r.label)}&quot;</span>`
                    : '';

                const tokenHtml = r.match_type === 'token' && r.matched_token !== r.label
                    ? `<span class="search-result-token">&quot;${escapeHtml(r.matched_token)}&quot;</span>`
                    : '';

                const badgeClass = r.match_type === 'label' ? 'label-match' : '';
                const badgeText = r.match_type === 'label' ? 'label' : 'token';

                return `
                    <div class="search-result" onclick="navigateToLatent(${r.latent_id})">
                        <span class="search-result-id">${r.latent_id}</span>
                        ${labelHtml}
                        ${tokenHtml}
                        <span class="search-result-badge ${badgeClass}">${badgeText}</span>
                        <span class="search-result-stats">${r.total_firings.toLocaleString()} firings</span>
                    </div>
                `;
            }).join('');

            panel.style.display = 'block';
        }

        function doSearch(query) {
            const results = searchLatents(query);
            renderSearchResults(results, query);
        }

        function navigateToLatent(id) {
            closeSearch();
            document.getElementById('search-input').value = '';
            loadLatent(id);
        }

        function closeSearch() {
            document.getElementById('search-results').style.display = 'none';
        }

        function handleSearchInput(e) {
            const query = e.target.value;
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = setTimeout(() => {
                if (!query || !query.trim()) {
                    closeSearch();
                    return;
                }
                doSearch(query);
            }, 150);
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            // Handle search input separately
            if (e.target.id === 'search-input') {
                if (e.key === 'Escape') {
                    closeSearch();
                    e.target.value = '';
                    e.target.blur();
                    e.preventDefault();
                }
                return;
            }

            // Don't intercept if typing in other inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                if (e.key === 'Enter') {
                    goToLatent();
                    e.target.blur();
                }
                if (e.key === 'Escape') {
                    e.target.blur();
                }
                return;
            }

            switch (e.key) {
                case 'ArrowLeft':
                    prevLatent();
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    nextLatent();
                    e.preventDefault();
                    break;
                case 'g':
                    document.getElementById('latent-input').focus();
                    document.getElementById('latent-input').select();
                    e.preventDefault();
                    break;
                case 'l':
                    toggleLogScale();
                    e.preventDefault();
                    break;
                case '/':
                    document.getElementById('search-input').focus();
                    document.getElementById('search-input').select();
                    e.preventDefault();
                    break;
                case 'Escape':
                    closeSearch();
                    break;
            }
        });

        // Handle input changes
        document.getElementById('latent-input').addEventListener('change', goToLatent);

        // Histogram click to toggle log scale
        document.getElementById('histogram-container').addEventListener('click', toggleLogScale);

        // Search input handler
        document.getElementById('search-input').addEventListener('input', handleSearchInput);

        // Embed mode: hide header for iframe embedding
        if (EMBED_MODE) {
            document.querySelector('.header').style.display = 'none';
            document.getElementById('search-results').style.display = 'none';
        }

        // Load experiments on page load
        loadExperiments();
    </script>
</body>
</html>
