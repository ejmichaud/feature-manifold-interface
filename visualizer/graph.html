<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAE Latent Graph Explorer</title>

    <!-- Graphology and Sigma.js -->
    <script src="https://cdn.jsdelivr.net/npm/graphology@0.25.4/dist/graphology.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/graphology-layout-forceatlas2@0.10.1/build/graphology-layout-forceatlas2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sigma@2.4.0/build/sigma.min.js"></script>

    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace;
            background: #1a1a2e;
            color: #eee;
            font-size: 12px;
            line-height: 1.4;
            overflow: hidden;
            height: 100vh;
        }

        /* Main layout */
        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 8px 16px;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
        }

        .header-title {
            font-size: 14px;
            font-weight: 600;
            color: #e94560;
        }

        .experiment-select {
            padding: 4px 8px;
            border: 1px solid #0f3460;
            border-radius: 4px;
            background: #1a1a2e;
            color: #eee;
            font-family: inherit;
            font-size: 11px;
            cursor: pointer;
        }

        .experiment-select:hover {
            border-color: #e94560;
        }

        .header-stats {
            font-size: 11px;
            color: #888;
            margin-left: auto;
        }

        .header-controls {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 4px 12px;
            border: 1px solid #0f3460;
            background: #16213e;
            color: #eee;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            transition: all 0.15s;
        }

        .btn:hover {
            border-color: #e94560;
            color: #e94560;
        }

        .btn.primary {
            background: #e94560;
            border-color: #e94560;
            color: white;
        }

        .btn.primary:hover {
            background: #ff6b6b;
            border-color: #ff6b6b;
        }

        /* Main content */
        .main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Left panel - Graph */
        .graph-panel {
            width: 40%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #0f3460;
            background: #1a1a2e;
        }

        .graph-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
        }

        .graph-title {
            font-weight: 600;
            font-size: 12px;
        }

        .graph-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-left: auto;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .control-label {
            font-size: 10px;
            color: #888;
        }

        .control-slider {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            background: #0f3460;
            border-radius: 2px;
            cursor: pointer;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #e94560;
            border-radius: 50%;
            cursor: pointer;
        }

        .control-value {
            font-size: 10px;
            color: #e94560;
            min-width: 24px;
        }

        .graph-container {
            flex: 1;
            position: relative;
            background: #0d0d1a;
        }

        #graph-canvas {
            width: 100%;
            height: 100%;
        }

        .graph-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
        }

        /* Right panel - Point Cloud */
        .cloud-panel {
            width: 60%;
            display: flex;
            flex-direction: column;
            background: #1a1a2e;
            overflow: hidden;
        }

        .cloud-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
        }

        .cloud-title {
            font-weight: 600;
            font-size: 12px;
        }

        .cloud-stats {
            font-size: 11px;
            color: #888;
            margin-left: auto;
        }

        .cloud-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 8px;
            gap: 8px;
        }

        /* 2D scatter grid: 3 rows x 4 cols */
        .scatter-grid-2d {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            flex: 3;
        }

        /* 3D scatter row: 1 row x 2 cols */
        .scatter-grid-3d {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
            flex: 1;
        }

        .scatter-cell {
            background: #0d0d1a;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .scatter-cell .plotly-graph-div {
            width: 100% !important;
            height: 100% !important;
        }

        .scatter-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #444;
            font-size: 10px;
            text-align: center;
        }

        /* Footer */
        .footer {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 16px;
            background: #16213e;
            border-top: 1px solid #0f3460;
        }

        .cluster-section {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .cluster-label {
            font-size: 11px;
            color: #888;
        }

        .cluster-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            max-height: 60px;
            overflow-y: auto;
        }

        .latent-chip {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            background: #e94560;
            color: white;
            border-radius: 12px;
            font-size: 10px;
            cursor: default;
        }

        .latent-chip .remove {
            cursor: pointer;
            opacity: 0.7;
            font-size: 12px;
        }

        .latent-chip .remove:hover {
            opacity: 1;
        }

        .cluster-empty {
            color: #666;
            font-style: italic;
            font-size: 11px;
        }

        .search-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .search-input {
            width: 80px;
            padding: 4px 8px;
            border: 1px solid #0f3460;
            border-radius: 4px;
            background: #1a1a2e;
            color: #eee;
            font-family: inherit;
            font-size: 11px;
        }

        .search-input:focus {
            outline: none;
            border-color: #e94560;
        }

        .save-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .saved-clusters-select {
            padding: 4px 8px;
            border: 1px solid #0f3460;
            border-radius: 4px;
            background: #1a1a2e;
            color: #eee;
            font-family: inherit;
            font-size: 11px;
            max-width: 150px;
        }

        /* Hover popup */
        .latent-popup {
            position: fixed;
            background: #16213e;
            border: 1px solid #0f3460;
            border-radius: 6px;
            padding: 12px;
            max-width: 350px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            display: none;
        }

        .popup-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #0f3460;
        }

        .popup-id {
            font-weight: 600;
            color: #e94560;
        }

        .popup-label {
            background: #e94560;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }

        .popup-stats {
            font-size: 10px;
            color: #888;
            margin-left: auto;
        }

        .popup-examples {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .popup-example {
            font-size: 11px;
            line-height: 1.4;
            padding: 4px 6px;
            background: #0d0d1a;
            border-radius: 4px;
        }

        .popup-example .token-highlight {
            background: rgba(233, 69, 96, 0.4);
            padding: 1px 2px;
            border-radius: 2px;
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #0f3460;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #0d0d1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #0f3460;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #e94560;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Header -->
        <header class="header">
            <span class="header-title">SAE Latent Graph Explorer</span>
            <select class="experiment-select" id="experiment-select">
                <option value="">Loading experiments...</option>
            </select>
            <span class="header-stats" id="header-stats">Loading...</span>
            <div class="header-controls">
                <button class="btn" id="btn-reset-view">Reset View</button>
                <button class="btn" id="btn-toggle-layout">Pause Layout</button>
            </div>
        </header>

        <!-- Main content -->
        <main class="main">
            <!-- Left: Graph -->
            <section class="graph-panel">
                <div class="graph-header">
                    <span class="graph-title">Latent Graph</span>
                    <div class="graph-controls">
                        <div class="control-group">
                            <span class="control-label">Edges/node:</span>
                            <input type="range" class="control-slider" id="max-edges-slider"
                                   min="1" max="10" value="5">
                            <span class="control-value" id="max-edges-value">5</span>
                        </div>
                        <div class="control-group">
                            <span class="control-label">Threshold:</span>
                            <input type="range" class="control-slider" id="threshold-slider"
                                   min="0" max="100" value="0">
                            <span class="control-value" id="threshold-value">0.00</span>
                        </div>
                        <select class="experiment-select" id="edge-type-select">
                            <option value="cosine">Cosine</option>
                            <option value="jaccard">Jaccard</option>
                        </select>
                    </div>
                </div>
                <div class="graph-container" id="graph-container">
                    <div class="graph-loading" id="graph-loading">
                        <span class="spinner"></span> Loading graph...
                    </div>
                </div>
            </section>

            <!-- Right: Point Cloud -->
            <section class="cloud-panel">
                <div class="cloud-header">
                    <span class="cloud-title">Activation Point Cloud (PCA)</span>
                    <span class="cloud-stats" id="cloud-stats">Select latents to view point cloud</span>
                </div>
                <div class="cloud-container">
                    <!-- 2D scatter grid: 3 rows x 4 cols = 12 plots -->
                    <div class="scatter-grid-2d" id="scatter-grid-2d">
                        <!-- PC pairs: (1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,10), (10,11), (11,12), (12,13) -->
                    </div>
                    <!-- 3D scatter row: 2 plots -->
                    <div class="scatter-grid-3d" id="scatter-grid-3d">
                        <!-- 3D views: PCs 1-3 and PCs 4-6 -->
                    </div>
                </div>
            </section>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <div class="cluster-section">
                <span class="cluster-label">Cluster:</span>
                <div class="cluster-chips" id="cluster-chips">
                    <span class="cluster-empty">Click latents on graph to add</span>
                </div>
            </div>
            <div class="search-section">
                <input type="number" class="search-input" id="latent-search"
                       placeholder="Latent ID" min="0">
                <button class="btn" id="btn-add-latent">Add</button>
            </div>
            <div class="save-section">
                <button class="btn" id="btn-clear-cluster">Clear</button>
                <button class="btn" id="btn-save-cluster">Save</button>
                <select class="saved-clusters-select" id="saved-clusters">
                    <option value="">Load saved...</option>
                </select>
            </div>
        </footer>
    </div>

    <!-- Latent hover popup -->
    <div class="latent-popup" id="latent-popup">
        <div class="popup-header">
            <span class="popup-id" id="popup-id">Latent 0</span>
            <span class="popup-label" id="popup-label"></span>
            <span class="popup-stats" id="popup-stats"></span>
        </div>
        <div class="popup-examples" id="popup-examples">
            <!-- Examples loaded dynamically -->
        </div>
    </div>

    <script>
        // ============================================================
        // Configuration
        // ============================================================
        // Data root can be set via ?dataRoot= URL param (default: ../data)
        const _urlParams = new URLSearchParams(window.location.search);
        const DATA_ROOT = _urlParams.get('dataRoot') || '../data';
        const EXPERIMENTS_ROOT = `${DATA_ROOT}/experiments`;
        const MANIFEST_URL = `${DATA_ROOT}/experiments.json`;
        const API_BASE = _urlParams.get('apiBase') || 'http://localhost:8000/api';

        // ============================================================
        // State
        // ============================================================
        const state = {
            experiments: [],
            currentExperiment: null,
            dataDir: null,

            // Graph data
            positions: null,
            edges: null,
            indexData: null,
            graph: null,
            renderer: null,

            // Layout
            layoutRunning: false,

            // Cluster
            cluster: new Set(),

            // Point cloud
            pcaData: null,

            // UI
            maxEdgesPerNode: 5,
            edgeThreshold: 0,
            edgeType: 'cosine',

            // Cache
            latentCache: new Map(),

            // Saved clusters
            savedClusters: [],
        };

        // ============================================================
        // Initialization
        // ============================================================
        async function init() {
            console.log('Initializing SAE Latent Graph Explorer...');

            // Load saved clusters from localStorage
            loadSavedClusters();

            // Setup event listeners
            setupEventListeners();

            // Initialize scatter plot placeholders
            initScatterPlots();

            // Load experiments
            await loadExperiments();
        }

        function setupEventListeners() {
            // Experiment selector
            document.getElementById('experiment-select').addEventListener('change', (e) => {
                if (e.target.value) switchExperiment(e.target.value);
            });

            // Edge controls
            document.getElementById('max-edges-slider').addEventListener('input', (e) => {
                state.maxEdgesPerNode = parseInt(e.target.value);
                document.getElementById('max-edges-value').textContent = state.maxEdgesPerNode;
                updateGraphEdges();
            });

            document.getElementById('threshold-slider').addEventListener('input', (e) => {
                state.edgeThreshold = parseInt(e.target.value) / 100;
                document.getElementById('threshold-value').textContent = state.edgeThreshold.toFixed(2);
                updateGraphEdges();
            });

            document.getElementById('edge-type-select').addEventListener('change', (e) => {
                state.edgeType = e.target.value;
                loadEdges();
            });

            // Header buttons
            document.getElementById('btn-reset-view').addEventListener('click', resetGraphView);
            document.getElementById('btn-toggle-layout').addEventListener('click', toggleLayout);

            // Cluster controls
            document.getElementById('btn-add-latent').addEventListener('click', addLatentFromSearch);
            document.getElementById('latent-search').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addLatentFromSearch();
            });
            document.getElementById('btn-clear-cluster').addEventListener('click', clearCluster);
            document.getElementById('btn-save-cluster').addEventListener('click', saveCluster);
            document.getElementById('saved-clusters').addEventListener('change', (e) => {
                if (e.target.value) loadCluster(e.target.value);
            });
        }

        // ============================================================
        // Experiment Loading
        // ============================================================
        async function loadExperiments() {
            const select = document.getElementById('experiment-select');

            try {
                const response = await fetch(MANIFEST_URL);
                if (!response.ok) throw new Error('No experiments manifest found');

                const manifest = await response.json();
                state.experiments = manifest.experiments.filter(e => e.has_visualizer);

                if (state.experiments.length === 0) {
                    select.innerHTML = '<option value="">No experiments available</option>';
                    return;
                }

                select.innerHTML = state.experiments.map(exp => {
                    const label = `Layer ${exp.layer} / ${exp.sae_width} / ${exp.sae_l0}`;
                    const tokens = exp.num_tokens ? ` (${(exp.num_tokens/1e6).toFixed(0)}M)` : '';
                    return `<option value="${exp.id}">${label}${tokens}</option>`;
                }).join('');

                // Check URL for experiment parameter
                const urlParams = new URLSearchParams(window.location.search);
                const expParam = urlParams.get('exp');
                const defaultExp = expParam && state.experiments.find(e => e.id === expParam)
                    ? expParam
                    : state.experiments[0].id;

                select.value = defaultExp;
                await switchExperiment(defaultExp);

            } catch (error) {
                console.error('Failed to load experiments:', error);
                select.innerHTML = '<option value="">Error loading experiments</option>';
            }
        }

        async function switchExperiment(experimentId) {
            if (!experimentId) return;

            state.currentExperiment = state.experiments.find(e => e.id === experimentId);
            state.dataDir = `${EXPERIMENTS_ROOT}/${experimentId}/visualizer`;

            // Update URL
            const url = new URL(window.location);
            url.searchParams.set('exp', experimentId);
            window.history.replaceState({}, '', url);

            // Reset state
            state.positions = null;
            state.edges = null;
            state.indexData = null;
            state.latentCache.clear();
            clearCluster();

            // Show loading
            document.getElementById('graph-loading').style.display = 'block';
            document.getElementById('header-stats').textContent = 'Loading...';

            // Load data
            await loadExperimentData();
        }

        async function loadExperimentData() {
            try {
                // Load positions and index in parallel
                const [posData, idxData] = await Promise.all([
                    fetch(`${state.dataDir}/positions.json`).then(r => r.json()),
                    fetch(`${state.dataDir}/index.json`).then(r => r.json())
                ]);

                state.positions = posData.positions;
                state.indexData = idxData;

                document.getElementById('header-stats').textContent =
                    `${state.positions.length.toLocaleString()} latents`;

                // Load edges
                await loadEdges();

                // Initialize graph
                initGraph();

            } catch (error) {
                console.error('Failed to load experiment data:', error);
                document.getElementById('graph-loading').innerHTML =
                    `<span style="color: #e94560;">Error: ${error.message}</span>`;
            }
        }

        async function loadEdges() {
            try {
                // Load edges from JSON file (exported by pipeline)
                const edgeFile = `${state.dataDir}/edges.json`;
                let edgeData;

                const response = await fetch(edgeFile);
                if (response.ok) {
                    edgeData = await response.json();
                } else {
                    // No edges file - warn but continue
                    console.warn('No edges.json found. Run export_edges_json.py to generate.');
                    state.edges = [];
                    return;
                }

                state.edges = edgeData.edges || [];
                console.log(`Loaded ${state.edges.length} edges from ${edgeFile}`);

                if (state.graph) {
                    updateGraphEdges();
                }

            } catch (error) {
                console.warn('Could not load edges:', error);
                state.edges = [];
            }
        }

        // ============================================================
        // Graph Rendering (sigma.js)
        // ============================================================
        function initGraph() {
            if (!state.positions) return;

            const container = document.getElementById('graph-container');

            // Clear existing renderer
            if (state.renderer) {
                state.renderer.kill();
                state.renderer = null;
            }

            // Create graphology graph
            state.graph = new graphology.Graph();

            // Compute bounds for normalization
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            for (const [x, y] of state.positions) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }

            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;
            const scale = 100;

            // Add nodes
            for (let i = 0; i < state.positions.length; i++) {
                const [x, y] = state.positions[i];
                const info = state.indexData?.latents?.[i.toString()];

                state.graph.addNode(i, {
                    x: ((x - minX) / rangeX - 0.5) * scale,
                    y: ((y - minY) / rangeY - 0.5) * scale,
                    size: 2,
                    color: '#666',
                    label: info?.label || `Latent ${i}`,
                });
            }

            // Add edges
            updateGraphEdges();

            // Create sigma renderer
            state.renderer = new Sigma(state.graph, container, {
                renderLabels: false,
                labelRenderedSizeThreshold: 100,
                defaultNodeColor: '#666',
                defaultEdgeColor: '#333',
                edgeReducer: (edge, data) => ({
                    ...data,
                    hidden: false,
                }),
                nodeReducer: (node, data) => {
                    const nodeId = parseInt(node);
                    return {
                        ...data,
                        color: state.cluster.has(nodeId) ? '#e94560' : '#666',
                        size: state.cluster.has(nodeId) ? 4 : 2,
                    };
                },
            });

            // Event handlers
            state.renderer.on('clickNode', ({ node }) => {
                toggleLatentInCluster(parseInt(node));
            });

            state.renderer.on('enterNode', ({ node }) => {
                showLatentPopup(parseInt(node));
            });

            state.renderer.on('leaveNode', () => {
                hideLatentPopup();
            });

            // Hide loading
            document.getElementById('graph-loading').style.display = 'none';

            // Start force layout
            startForceLayout();
        }

        function updateGraphEdges() {
            if (!state.graph || !state.edges) return;

            // Clear existing edges
            state.graph.clearEdges();

            // Count edges per node
            const edgeCounts = new Map();

            // Filter and sort edges by weight
            const filteredEdges = state.edges
                .filter(e => e.weight >= state.edgeThreshold)
                .sort((a, b) => b.weight - a.weight);

            // Add edges respecting max per node
            for (const edge of filteredEdges) {
                const sourceCount = edgeCounts.get(edge.source) || 0;
                const targetCount = edgeCounts.get(edge.target) || 0;

                if (sourceCount < state.maxEdgesPerNode && targetCount < state.maxEdgesPerNode) {
                    try {
                        state.graph.addEdge(edge.source, edge.target, {
                            weight: edge.weight,
                            size: Math.max(0.5, edge.weight * 2),
                            color: `rgba(100, 100, 150, ${0.2 + edge.weight * 0.5})`,
                        });
                        edgeCounts.set(edge.source, sourceCount + 1);
                        edgeCounts.set(edge.target, targetCount + 1);
                    } catch (e) {
                        // Edge might already exist or nodes don't exist
                    }
                }
            }

            console.log(`Graph has ${state.graph.order} nodes, ${state.graph.size} edges`);

            if (state.renderer) {
                state.renderer.refresh();
            }
        }

        function startForceLayout() {
            if (!state.graph) return;

            state.layoutRunning = true;
            document.getElementById('btn-toggle-layout').textContent = 'Pause Layout';

            // Run ForceAtlas2
            const settings = {
                iterations: 100,
                settings: {
                    gravity: 1,
                    scalingRatio: 2,
                    slowDown: 10,
                    barnesHutOptimize: true,
                    barnesHutTheta: 0.5,
                },
            };

            // Use web worker if available
            if (typeof ForceAtlas2Layout !== 'undefined' && ForceAtlas2Layout.inferSettings) {
                const inferredSettings = ForceAtlas2Layout.inferSettings(state.graph);
                Object.assign(settings.settings, inferredSettings);
            }

            // Run layout iterations
            let iteration = 0;
            const maxIterations = 100;

            function layoutStep() {
                if (!state.layoutRunning || iteration >= maxIterations) {
                    state.layoutRunning = false;
                    document.getElementById('btn-toggle-layout').textContent = 'Resume Layout';
                    return;
                }

                forceAtlas2.assign(state.graph, {
                    iterations: 1,
                    settings: settings.settings,
                });

                iteration++;
                requestAnimationFrame(layoutStep);
            }

            layoutStep();
        }

        function toggleLayout() {
            if (state.layoutRunning) {
                state.layoutRunning = false;
                document.getElementById('btn-toggle-layout').textContent = 'Resume Layout';
            } else {
                startForceLayout();
            }
        }

        function resetGraphView() {
            if (state.renderer) {
                state.renderer.getCamera().animatedReset();
            }
        }

        // ============================================================
        // Latent Popup
        // ============================================================
        async function showLatentPopup(latentId) {
            const popup = document.getElementById('latent-popup');

            // Position popup near cursor
            const rect = document.getElementById('graph-container').getBoundingClientRect();
            popup.style.left = (rect.right - 360) + 'px';
            popup.style.top = (rect.top + 10) + 'px';
            popup.style.display = 'block';

            // Set header
            document.getElementById('popup-id').textContent = `Latent ${latentId}`;

            const info = state.indexData?.latents?.[latentId.toString()];
            const labelEl = document.getElementById('popup-label');
            if (info?.label) {
                labelEl.textContent = `"${info.label}"`;
                labelEl.style.display = 'inline-block';
            } else {
                labelEl.style.display = 'none';
            }

            document.getElementById('popup-stats').textContent =
                info?.total_firings ? `${info.total_firings.toLocaleString()} firings` : '';

            // Load examples
            const examplesEl = document.getElementById('popup-examples');
            examplesEl.innerHTML = '<span class="spinner"></span> Loading...';

            try {
                const data = await loadLatentData(latentId);
                renderPopupExamples(data);
            } catch (error) {
                examplesEl.innerHTML = `<span style="color: #e94560;">Error loading examples</span>`;
            }
        }

        function hideLatentPopup() {
            document.getElementById('latent-popup').style.display = 'none';
        }

        async function loadLatentData(latentId) {
            if (state.latentCache.has(latentId)) {
                return state.latentCache.get(latentId);
            }

            const paddedId = String(latentId).padStart(5, '0');
            const response = await fetch(`${state.dataDir}/latents/${paddedId}.json`);
            if (!response.ok) throw new Error('Failed to load latent data');

            const data = await response.json();

            // Keep cache size manageable
            if (state.latentCache.size > 100) {
                const firstKey = state.latentCache.keys().next().value;
                state.latentCache.delete(firstKey);
            }

            state.latentCache.set(latentId, data);
            return data;
        }

        function renderPopupExamples(data) {
            const examplesEl = document.getElementById('popup-examples');

            // Get top examples
            let examples = [];
            if (data.examples?.top) {
                examples = data.examples.top.slice(0, 5);
            } else if (data.top_examples) {
                examples = data.top_examples.slice(0, 5);
            }

            if (examples.length === 0) {
                examplesEl.innerHTML = '<span style="color: #888;">No examples</span>';
                return;
            }

            examplesEl.innerHTML = examples.map(ex => {
                const tokens = ex.tokens || [];
                const activations = ex.token_activations || [];
                const maxAct = ex.max_activation || Math.max(...activations.filter(a => a > 0), 0.001);

                const html = tokens.map((token, i) => {
                    const act = activations[i] || 0;
                    const escaped = escapeHtml(token);
                    if (act > 0) {
                        return `<span class="token-highlight">${escaped}</span>`;
                    }
                    return escaped;
                }).join('');

                return `<div class="popup-example">${html}</div>`;
            }).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================================
        // Cluster Management
        // ============================================================
        function toggleLatentInCluster(latentId) {
            if (state.cluster.has(latentId)) {
                state.cluster.delete(latentId);
            } else {
                state.cluster.add(latentId);
            }

            updateClusterUI();
            updatePointCloud();

            // Update graph node appearance
            if (state.renderer) {
                state.renderer.refresh();
            }
        }

        function addLatentFromSearch() {
            const input = document.getElementById('latent-search');
            const latentId = parseInt(input.value);

            if (isNaN(latentId) || latentId < 0 || latentId >= state.positions?.length) {
                return;
            }

            state.cluster.add(latentId);
            updateClusterUI();
            updatePointCloud();

            if (state.renderer) {
                state.renderer.refresh();
            }

            input.value = '';
        }

        function removeLatentFromCluster(latentId) {
            state.cluster.delete(latentId);
            updateClusterUI();
            updatePointCloud();

            if (state.renderer) {
                state.renderer.refresh();
            }
        }

        function clearCluster() {
            state.cluster.clear();
            updateClusterUI();
            clearPointCloud();

            if (state.renderer) {
                state.renderer.refresh();
            }
        }

        function updateClusterUI() {
            const chipsEl = document.getElementById('cluster-chips');

            if (state.cluster.size === 0) {
                chipsEl.innerHTML = '<span class="cluster-empty">Click latents on graph to add</span>';
                return;
            }

            const chips = Array.from(state.cluster).sort((a, b) => a - b).map(id => {
                const info = state.indexData?.latents?.[id.toString()];
                const label = info?.label ? ` "${info.label}"` : '';
                return `
                    <span class="latent-chip">
                        ${id}${label}
                        <span class="remove" onclick="removeLatentFromCluster(${id})">Ã—</span>
                    </span>
                `;
            }).join('');

            chipsEl.innerHTML = chips;
        }

        // ============================================================
        // Saved Clusters
        // ============================================================
        function loadSavedClusters() {
            const saved = localStorage.getItem('savedClusters');
            state.savedClusters = saved ? JSON.parse(saved) : [];
            updateSavedClustersUI();
        }

        function updateSavedClustersUI() {
            const select = document.getElementById('saved-clusters');
            select.innerHTML = '<option value="">Load saved...</option>' +
                state.savedClusters.map((c, i) =>
                    `<option value="${i}">${c.name} (${c.latents.length} latents)</option>`
                ).join('');
        }

        function saveCluster() {
            if (state.cluster.size === 0) return;

            const name = prompt('Enter a name for this cluster:',
                `Cluster ${state.savedClusters.length + 1}`);
            if (!name) return;

            state.savedClusters.push({
                name,
                latents: Array.from(state.cluster),
                experiment: state.currentExperiment?.id,
                timestamp: Date.now(),
            });

            localStorage.setItem('savedClusters', JSON.stringify(state.savedClusters));
            updateSavedClustersUI();
        }

        function loadCluster(index) {
            const saved = state.savedClusters[index];
            if (!saved) return;

            state.cluster = new Set(saved.latents);
            updateClusterUI();
            updatePointCloud();

            if (state.renderer) {
                state.renderer.refresh();
            }

            // Reset select
            document.getElementById('saved-clusters').value = '';
        }

        // ============================================================
        // Point Cloud (Plotly)
        // ============================================================
        function initScatterPlots() {
            const grid2d = document.getElementById('scatter-grid-2d');
            const grid3d = document.getElementById('scatter-grid-3d');

            // Create 12 2D scatter cells
            const pcPairs = [
                [1,2], [2,3], [3,4], [4,5],
                [5,6], [6,7], [7,8], [8,9],
                [9,10], [10,11], [11,12], [12,13]
            ];

            grid2d.innerHTML = pcPairs.map(([a, b], i) => `
                <div class="scatter-cell" id="scatter-2d-${i}">
                    <div class="scatter-placeholder">PC${a} vs PC${b}</div>
                </div>
            `).join('');

            // Create 2 3D scatter cells
            grid3d.innerHTML = `
                <div class="scatter-cell" id="scatter-3d-0">
                    <div class="scatter-placeholder">PC1-2-3 (3D)</div>
                </div>
                <div class="scatter-cell" id="scatter-3d-1">
                    <div class="scatter-placeholder">PC4-5-6 (3D)</div>
                </div>
            `;
        }

        async function updatePointCloud() {
            if (state.cluster.size === 0) {
                clearPointCloud();
                return;
            }

            document.getElementById('cloud-stats').innerHTML =
                `<span class="spinner"></span> Computing PCA...`;

            try {
                // Call backend API for PCA
                const response = await fetch(`${API_BASE}/cluster/pca`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        latent_ids: Array.from(state.cluster),
                        n_components: 13,
                        max_points: 50000,
                        experiment_id: state.currentExperiment?.id,
                    }),
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                state.pcaData = data;

                document.getElementById('cloud-stats').textContent =
                    `${data.n_points.toLocaleString()} points | ` +
                    `Var explained: ${(data.explained_variance_ratio.slice(0, 6).reduce((a, b) => a + b, 0) * 100).toFixed(1)}% (PC1-6)`;

                renderScatterPlots(data);

            } catch (error) {
                console.error('Failed to compute PCA:', error);
                document.getElementById('cloud-stats').textContent =
                    `Error: ${error.message}. Is the backend running?`;
            }
        }

        function clearPointCloud() {
            state.pcaData = null;
            document.getElementById('cloud-stats').textContent = 'Select latents to view point cloud';

            // Clear all plots
            for (let i = 0; i < 12; i++) {
                const el = document.getElementById(`scatter-2d-${i}`);
                if (el) {
                    const pcPairs = [[1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [7,8], [8,9], [9,10], [10,11], [11,12], [12,13]];
                    el.innerHTML = `<div class="scatter-placeholder">PC${pcPairs[i][0]} vs PC${pcPairs[i][1]}</div>`;
                }
            }

            for (let i = 0; i < 2; i++) {
                const el = document.getElementById(`scatter-3d-${i}`);
                if (el) {
                    const labels = ['PC1-2-3 (3D)', 'PC4-5-6 (3D)'];
                    el.innerHTML = `<div class="scatter-placeholder">${labels[i]}</div>`;
                }
            }
        }

        function renderScatterPlots(data) {
            if (!data.points || data.points.length === 0) {
                clearPointCloud();
                return;
            }

            const points = data.points;
            const nComponents = points[0].length;

            // Extract columns
            const pcs = [];
            for (let i = 0; i < nComponents; i++) {
                pcs.push(points.map(p => p[i]));
            }

            // Common layout settings
            const layoutBase = {
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(13,13,26,1)',
                margin: { l: 25, r: 5, t: 20, b: 25 },
                font: { color: '#888', size: 9 },
                xaxis: {
                    gridcolor: '#1a1a2e',
                    zerolinecolor: '#333',
                    tickfont: { size: 8 }
                },
                yaxis: {
                    gridcolor: '#1a1a2e',
                    zerolinecolor: '#333',
                    tickfont: { size: 8 }
                },
            };

            // Render 2D plots
            const pcPairs = [
                [0,1], [1,2], [2,3], [3,4],
                [4,5], [5,6], [6,7], [7,8],
                [8,9], [9,10], [10,11], [11,12]
            ];

            pcPairs.forEach(([a, b], i) => {
                if (a >= nComponents || b >= nComponents) return;

                const el = document.getElementById(`scatter-2d-${i}`);
                if (!el) return;

                el.innerHTML = '';  // Clear placeholder

                const trace = {
                    x: pcs[a],
                    y: pcs[b],
                    mode: 'markers',
                    type: 'scattergl',
                    marker: {
                        size: 2,
                        color: '#e94560',
                        opacity: 0.5,
                    },
                };

                const layout = {
                    ...layoutBase,
                    xaxis: { ...layoutBase.xaxis, title: { text: `PC${a+1}`, font: { size: 9 } } },
                    yaxis: { ...layoutBase.yaxis, title: { text: `PC${b+1}`, font: { size: 9 } } },
                };

                Plotly.newPlot(el, [trace], layout, {
                    responsive: true,
                    displayModeBar: false,
                });
            });

            // Render 3D plots
            const plot3dConfigs = [
                { pcs: [0, 1, 2], label: 'PC1-2-3' },
                { pcs: [3, 4, 5], label: 'PC4-5-6' },
            ];

            plot3dConfigs.forEach((config, i) => {
                const [a, b, c] = config.pcs;
                if (a >= nComponents || b >= nComponents || c >= nComponents) return;

                const el = document.getElementById(`scatter-3d-${i}`);
                if (!el) return;

                el.innerHTML = '';  // Clear placeholder

                const trace = {
                    x: pcs[a],
                    y: pcs[b],
                    z: pcs[c],
                    mode: 'markers',
                    type: 'scatter3d',
                    marker: {
                        size: 2,
                        color: '#e94560',
                        opacity: 0.5,
                    },
                };

                const layout = {
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    margin: { l: 0, r: 0, t: 0, b: 0 },
                    scene: {
                        bgcolor: 'rgba(13,13,26,1)',
                        xaxis: { title: `PC${a+1}`, gridcolor: '#1a1a2e', tickfont: { size: 8 } },
                        yaxis: { title: `PC${b+1}`, gridcolor: '#1a1a2e', tickfont: { size: 8 } },
                        zaxis: { title: `PC${c+1}`, gridcolor: '#1a1a2e', tickfont: { size: 8 } },
                    },
                };

                Plotly.newPlot(el, [trace], layout, {
                    responsive: true,
                    displayModeBar: false,
                });
            });
        }

        // ============================================================
        // Start
        // ============================================================
        init();
    </script>
</body>
</html>
